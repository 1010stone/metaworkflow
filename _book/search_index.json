[
["raw-data-pretreatment.html", "Chapter 3 Raw data pretreatment 3.1 Spectral deconvolution 3.2 Correction 3.3 Non-detects 3.4 Adjust for unwanted variance with known batch 3.5 Adjust for unwanted variance with unknown batch", " Chapter 3 Raw data pretreatment Raw data from the instruments such as LC-MS or GC-MS were hard to be analyzed. To make it clear, the structure of those data could be summarised as: to get full infomation in the samples, full scan is perferred; full scan is performed with the seperation process; GC/LC-MS data are usually be shown as a matrix with column standing for retention times and row standing for masses. Noises are so much that such data could not be processed effeciently. Figure 3.1: Demo of GC/LC-MS data Conversation from the mass-retention time matrix into a vector with selected MS peaks at certain retention time is the basic idea of the Raw data pretreatment. With many groups of samples, you will get another data matrix with column standing for ions at cerntain retention time and row standing for samples after the Raw data pretreatment. Figure 3.2: Demo of many GC/LC-MS data 3.1 Spectral deconvolution Without fracmental infomation about certain compound, the peak extraction would suffer influnces from other compounds. At the same retention time, co-elute compounds might share similar mass. So it would be hard to distighuish the co-elute peaks’ origin and deconvolution method(Du and Zeisel 2013) could be used to seperate different groups according to the similar chromatogragh beheviors. 3.2 Correction However, before you get the peaks, some corrections should be performed such as mass shift and retention time shift. The basic idea behind retention time correction is that use the high quality grouped peaks to make a new retention time. You might choose obiwarp or loess regression method to get the corrected retention time for all of the samples. Remember the original retention times might be changed and you might need cross-correct for mass data correction. 3.3 Non-detects Some of the data were limited by the detect of limitation. Thus we need some methods to impute the data if we don’t want to lose information by deleting the NA or 0. Tobit regression is preferred. Also you might choose maximum likelihood estimation(Estimation of mean and standard deviation by MLE. Creating 10 complete samples. Pool the results from 10 individual analyses). x &lt;- rnorm(1000,1) x[x&lt;0] &lt;- 0 y &lt;- x*10+1 library(AER) ## Loading required package: car ## Loading required package: lmtest ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## Loading required package: sandwich ## Loading required package: survival tfit &lt;- tobit(y ~ x, left = 0) summary(tfit) ## ## Call: ## tobit(formula = y ~ x, left = 0) ## ## Observations: ## Total Left-censored Uncensored Right-censored ## 1000 0 1000 0 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 1.0000 0.4514 2.215 0.0267 * ## x 10.0000 0.3162 31.623 &lt;2e-16 *** ## Log(scale) 2.1588 0.0000 Inf &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Scale: 8.661 ## ## Gaussian distribution ## Number of Newton-Raphson Iterations: 1 ## Log-likelihood: -3078 on 3 Df ## Wald-statistic: 1000 on 1 Df, p-value: &lt; 2.22e-16 3.4 Adjust for unwanted variance with known batch 3.4.1 Centering For peak p of sample s in batch b, the corrected abundance I is: \\[\\hat I_{p,s,b} = I_{p,s,b} - mean(I_{p,b}) + median(I_{p,qc})\\] For example, we have the intensities of one peak from ten samples in two batches like the following demo: set.seed(42) # raw data I = c(rnorm(10,mean = 0, sd = 0.5),rnorm(10,mean = 1, sd = 0.5)) # batch B = c(rep(0,10),rep(1,10)) # qc Iqc = c(rnorm(1,mean = 0, sd = 0.5),rnorm(1,mean = 1, sd = 0.5)) # corrected data Icor = I - c(rep(mean(I[1:10]),10),rep(mean(I[11:20]),10)) + median(Iqc) # plot the result plot(I) plot(Icor) 3.4.2 Scaling For peak p of sample s in certain batch b, the corrected abundance I is: \\[\\hat I_{p,s,b} = \\frac{I_{p,s,b} - mean(I_{p,b})}{std_{p,b}} * std_{p,qc,b} + mean(I_{p,qc,b})\\] For example, we have the intensities of one peak from ten samples in two batches like the following demo: set.seed(42) # raw data I = c(rnorm(10,mean = 0, sd = 0.3),rnorm(10,mean = 1, sd = 0.5)) # batch B = c(rep(0,10),rep(1,10)) # qc Iqc = c(rnorm(1,mean = 0, sd = 0.3),rnorm(1,mean = 1, sd = 0.5)) # corrected data Icor = (I - c(rep(mean(I[1:10]),10),rep(mean(I[11:20]),10)))/c(sd(I[1:10]),sd(I[11:20]))*c(rep(0.3,10),rep(0.5,10)) + Iqc[1] # plot the result plot(I) plot(Icor) 3.4.3 Quantile The idea of quantile calibration is that alignment of the intensities in certain samples according to quantiles in each sample. Here is the demo: set.seed(42) a &lt;- rnorm(1000) # b sufferred batch effect with a bias of 10 b &lt;- rnorm(1000,10) hist(a,xlim=c(-5,15),breaks = 50) hist(b,col = &#39;black&#39;, breaks = 50, add=T) # quantile normalized cor &lt;- (a[order(a)]+b[order(b)])/2 # reorder cor &lt;- cor[order(order(a))] hist(cor,col = &#39;red&#39;, breaks = 50, add=T) 3.4.4 Ratio based calibraton This method calibrates samples by the ratio between qc samples in all samples and in certain batch.For peak p of sample s in certain batch b, the corrected abundance I is: \\[\\hat I_{p,s,b} = \\frac{I_{p,s,b} * median(I_{p,qc})}{mean_{p,qc,b}}\\] set.seed(42) # raw data I = c(rnorm(10,mean = 0, sd = 0.3),rnorm(10,mean = 1, sd = 0.5)) # batch B = c(rep(0,10),rep(1,10)) # qc Iqc = c(rnorm(1,mean = 0, sd = 0.3),rnorm(1,mean = 1, sd = 0.5)) # corrected data Icor = I * median(c(rep(Iqc[1],10),rep(Iqc[2],10)))/mean(c(rep(Iqc[1],10),rep(Iqc[2],10))) # plot the result plot(I) plot(Icor) 3.4.5 Linear Normalizer This method initially scales each sample so that the sum of all peak abundances equals one. In this study, by multiplying the median sum of all peak abundances across all samples,we got the corrected data. set.seed(42) # raw data peaksa &lt;- c(rnorm(10,mean = 10, sd = 0.3),rnorm(10,mean = 20, sd = 0.5)) peaksb &lt;- c(rnorm(10,mean = 10, sd = 0.3),rnorm(10,mean = 20, sd = 0.5)) df &lt;- rbind(peaksa,peaksb) dfcor &lt;- df/apply(df,2,sum)* sum(apply(df,2,median)) image(df) image(dfcor) 3.4.6 Regression calibration Considering the batch effect of injection order, regress the data by a linear model to get the calibration. 3.4.7 Batch Normalizer Use the total abundance scale and then fit with the regression line(Wang, Kuo, and Tseng 2013). 3.4.8 Internal standards \\[\\hat I_{p,s} = \\frac{I_{p,s} * median(I_{IS})}{I_{IS,s}}\\] Some methods also use pooled calibration samples and multiple internal standard strategy to correct the data(van der Kloet et al. 2009). Also some methods only use QC samples to handle the data(Kuligowski et al. 2015). 3.5 Adjust for unwanted variance with unknown batch 3.5.1 SVA 3.5.2 RUV Demo "]
]
